# 事务

1. 原子性：特指一个事务的原子性，与并发事务无关
2. 一致性：这更多是一种业务上的概念，就好比A给B转钱，无论转账成功/失败，A和B的总资产应该是不变的。
3. 隔离性：多个事务同时执行，相互不冒犯
4. 持久性：是数据库的一个承诺，事务一旦提交成功，任何写入的数据都不会消失

# 事务的隔离级别

## 读已提交

提供两个保证
1. 从数据库读时，只能看到已经提交的数据，换而言之，一个事务的任何写入操作只有在它提交后，才能被其他事务看到。（没有脏读**dirty read**）
2. 写入数据时，只会覆盖已经写入的数据。（没有脏写**dirty writes**）

**脏读**：一个事务看到了另一个事务未提交的数据。
**脏写**：多个事务修改数据库中相同的对象，（通常认为后来的事务会覆盖之前事务的写入）如果先前的事务修改了数据，但未提交，接着该数据被后来的事务给重写了。

在**读已提交**的隔离级别下，**不可重复读**是可以接受的，为了支持**可重复读**，一般都是通过**快照隔离**来实现，同时**快照隔离**也可以用来防止**脏写**，即正在写入的事务会阻止另一个事务来修改同一个对象，但是不同的事务读取同一个对象是不受限制的。实现**快照隔离**意味着数据库要维护同一个数据对象的多个版本，进而衍生为**MVCC**。

## 可重复读

当一个事务在读取数据的时候，该事务的ID决定它能看到那些对象的哪些版本，可见性规则基本如下：
1. 事务开始时，要记住当前数据库中所有活跃的事务（它们将来会被提交/回滚），这些活跃事务的任何写入对当前事务来说，都不可见。
2. 如果数据的版本高于当前事务的ID，那么也不可见，确切来说，高版本的事务所做的修改对当前事务不可见。
3. 其他的修改都是可见

也有**缺点**，如果一个事务执行的时间很长，那么该事务的快照会持续很久，它会一直在使用数据的旧版本。

## 幻读

其实**幻读**很难解决，通俗来说（**两次查询的数据量不一样**）mySQL的间隙锁+记录锁在很大的程度上解决了幻读。

首先：在快照读的场景下，可以通过**MVCC**解决幻读，但是当前读不好说，很多时候我们能解决幻读，那是因为我们的条件不够苛刻，有一个经典案例很有意思。

> 医务值班室，要求至少一名医生在值班，当前有两位医生在值班，突然他两身体都不舒服，他两在请假之前确认了自己请假后还有一名医生，然后他两同时请假。结果医务室没人值班。

可以把两个医生请假是为两个事务，这两个事务没任何冲突，但产生的结果不能接受。这需要**谓词锁**来做限制，不过这很宽泛了，不在考虑范围之内。

# MVCC

这里给出本项目实现MVCC的方案，大体思路和toyDB很

| keys| | | | | | |
| - | -  | - | -  | -  | - | - |
| a | a1 |   |    | a4 |   |   |
| b |    |   | b3 |    |   |   |
| c | c1 |   |    |    |   |   |
| d | d1 |   | x  |    |   |   |
|   | 1  | 2 | 3  | 4  |5  | version |

如图，我们有a b c d四个key，已经它们多个版本的value，那么TX_id = 2的事务能看的数据是 a = a1， c = c1， d = d1。TX_id = 2的事务能看的数据是 a = a4， c = c1， b = b3。

## 事务ID

每次新发起一个事务，都要确保是全局递增的，这个可以用底层原子自增来实现。通过事务ID的大小来决定新旧版本。

## 隔离性

为每一个事务创建一个一致性快照，和当前事务并发冲突的事务，或者是将来的事务，都对当前事务不可见。

新发起事务的时候，要记下当前系统中的活跃事务，就是哪些还未提交的事务。例如当前有一个事务a1在修改a，这时候新发起一个事务a2，a2会知道a1还没有提交，如果a2这时候修改b，那么a2会顺利完成修改，接着提交事务。但是呢如果a2修好a，那a2会发现当前有活跃的事务正在修改a，那么a2就会放弃修改a。当a1提交后，a1变不在是活跃事务了，当前系统中，没有事务霸占着a。

| keys| | | | | | |
| - | -  | -  | -  | -  | -  | - |
| a | a1 |    |    | a4 |(a5)|   |
| b |    |    | b3 |    |    |   |
| c | c1 | (x)|    |    |    |   |
| d | d1 |    | x  |    |    |   |
| e |    |(e2)|    |    |    |   |
|   | 1  | 2  | 3  | 4  |5   | version |


这里用括号来表示未提交的修改，当前系统中有两个活跃的事务 TX_id = 2，TX_id = 5。TX_id = 2的事务能看的数据是 a = a1， e = e2， d = d1。（它能看到它自己的修改）TX_id = 5的事务能看的数据是 a = a5， b = b3， c = c1。T2对T5来说，是一个活跃事务，所以T5看不到T2的修改。

如果T2想修改b，这是不允许的，因为b已经有一个更高版本的value b3了，如果T5想要修改e，这也是不允许的，因为已经有一个活跃的事务T2正在修改e。

T2提交后，T5还能看到T2的修改吗，这里为了简单，依然让T5看不到T2，反正在创建T5的时候，T2是活跃的事务，不然对T5来说，**不可重复读**